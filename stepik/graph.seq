from extensions import *
from adjGraph import *
from helpers import *

def eulerianPath(ag:Adjacency, kind='cycle', start=s'') -> Seqs:
   """ See http://www.graph-magics.com/articles/euler.php
   """
   stack = Seqs()
   res = Seqs()
   keys = list(ag.keys())
   nVertices = len(keys)
   paths = {key: vals for key, vals in ag.items()}
   inCnt = {key: 0 for key in keys}
   outCnt = {key: 0 for key in keys}
   cur = s''

   # Set in/out counts map
   for key, vals in ag.items():
      outCnt[key] += len(vals)
      for val in vals:
         inCnt[val] = 1 if val not in inCnt else inCnt[val] + 1

   eqIOCnts = sum(1 for k in keys if inCnt[k]==outCnt[k])
   notEqIOKeys = [k for k in keys if inCnt[k] != outCnt[k]]
   inGTOutKeys = [k for k in notEqIOKeys if inCnt[k] > outCnt[k]]
   outGTInKeys = [k for k in notEqIOKeys if outCnt[k] > inCnt[k]]
   maxResLen = sum(len(vals) for key, vals in ag.items()) + 1
   # print '=iocnts', eqIOCnts
   # print 'not=ioKeys', notEqIOKeys
   # print 'verts', nVertices

   if len(keys) == 0:
      return res
   elif len(keys) == 1:
      cur = keys[0]
   elif len(start) > 0:
      cur = start

   # 1. Choose starting vertex
   # If all vertices have same fanout as fanin
   elif eqIOCnts == nVertices:
      # choose one with more than 1 fanout
      for i, key in enumerate(keys):
         if len(ag[key]) > 1:
            cur = key
            break
      # or one with more than 1 fanin if exists, else choose any, eg. 1st one
      if cur == s'':
         cur = inGTOutKeys[0] if len(inGTOutKeys) > 0 else keys[0]
         print 'here, cur=AT', cur

   # If all but 2 vertices have same out-degree as in-degree
   elif eqIOCnts == nVertices - 2:
      if len(outGTInKeys)==len(inGTOutKeys):
         outGTkey = outGTInKeys[0]
         inGTkey = inGTOutKeys[0]
         # If 1 of the 2 vertices has fanout 1 > fanin and the other is opposite then
         #  set cur to vertex w/ fanout 1 > fanin 
         if inCnt[inGTkey]+1 == outCnt[inGTkey] and outCnt[outGTkey]+1 == inCnt[outGTkey]:
            cur = outGTkey

   # Else no euler cycle exists if cur isn't set
   # print 'start|cur', start,'|', cur, start==cur
   if kind=='cycle' and cur == s'':
      return res

   # Path finding, set cur to key that has fanout > fanin
   if cur == s'' and kind != 'cycle':
      cur = outGTInKeys[0] if len(outGTInKeys) > 0 else keys[0]

   # 2. Repeat until current vertex has no more out-going edges and stack is empty:
   while len(res) < maxResLen and cur != s'':
      nexts = Seqs() if kind != 'cycle' and cur not in paths else paths[cur]

      # If current vertex has no out-edges, add it to cycle and
      # remove the last vertex from the stack and set it as the current one
      if len(nexts) > 0:
         stack.append(cur)
         cur = nexts.pop(0)
      # Else, add the vertex to the stack, take any of its out-vertices and
      # remove that out-edge and set that out-vertex as the current vertex
      else:
         res.append(cur)
         cur = stack.pop() if len(stack) > 0 else s''

   if cur != s'':
      res.append(cur)
   while len(stack) > 0:
      res.append(stack.pop())
   res.reverse()
   return res

def genomeFromSeqs(seqs:Seqs, kind='path', start=s'') -> seq: 
# def genomeFromSeqs(seqs:Seqs, method='kmers', kind='path') -> seq: 
   """ Reconstruct genome from seqs with method and kind, with
   kind one of 'cycle' | 'path' | 'universal'
   """
   ag = AdjGraph(seqs, 'kmers', 0).ag # 'overlap' only works for very few cases
   # print 'ag', ag
   path = eulerianPath(ag, kind, start)
   # print 'path', path
   dna = path |> concatAdjSeqs
   # print 'dna', dna
   # dna = eulerianPath(ag, kind) |> concatAdjSeqs
   if kind != 'universal':
      return dna 
   k = len(seqs[0]) - 1
   i = k // 2
   isOdd = k % 2 == 1 
   res = dna[i:-i]
   return res[1:] if isOdd else res

def unzipToSeqs(strPairs:StrPairs): 
   """ a, b = zip(*sps) (doesn't work in seq)
   """
   A = [seq(sp[0]) for sp in strPairs]
   B = [seq(sp[1]) for sp in strPairs]
   return A, B

def pairedComposition(ptn:seq, k:int, d:int) -> Pairs:
   """ Returns pairs of ptn formed by its (k, d)-mer
   """
   s = list(ptn.split(k, 1))
   l = len(ptn) -k -d -2
   return [(x, y) for x,y in zip(s[:l], s[k+d:])]

def unzip(strPairs:StrPairs) -> tuple[Strs, Strs]: 
   """ a, b = zip(*sps) (doesn't work in seq)
   """
   A = [sp[0] for sp in strPairs]
   B = [sp[1] for sp in strPairs]
   return A, B

def unzipToSeqs(strPairs:StrPairs) -> tuple[Seqs, Seqs]: 
   """ a, b = zip(*sps) (doesn't work in seq)
   """
   A = [seq(sp[0]) for sp in strPairs]
   B = [seq(sp[1]) for sp in strPairs]
   return A, B


def genomeFromOrderedPairs(strPairs:StrPairs, k:int, d:int) -> seq:
   pair0 = strPairs[0]
   A, B = unzip(strPairs) 
   ptns1 = pair0[0] + ''.join([a[-1] for a in A[1:]])
   ptns2 = pair0[1] + ''.join([b[-1] for b in B[1:]])
   l = len(ptns1)
   if ptns1[k+d:] != ptns2[:l-k-d]:
      print 'WARN: No string spelled by the gapped patterns'
   return seq(ptns1 + ptns2[-(k+d):])
