from extensions import *
from adjGraph import *

def eulerianPath(ag:Adjacency, kind='cycle') -> Seqs:
   """ See http://www.graph-magics.com/articles/euler.php
   """
   stack = Seqs()
   res = Seqs()
   keys = list(ag.keys())
   nVertices = len(keys)
   paths = {key: vals for key, vals in ag.items()}
   inCnt = {key: 0 for key in keys}
   outCnt = {key: 0 for key in keys}
   cur = s''

   # Set in/out counts map
   for key, vals in ag.items():
      outCnt[key] += len(vals)
      for val in vals:
         inCnt[val] = 1 if val not in inCnt else inCnt[val] + 1

   eqIOCnts = sum(1 for k in keys if inCnt[k]==outCnt[k])
   notEqIOKeys = [k for k in keys if inCnt[k] != outCnt[k]]
   inGTOutKeys = [k for k in notEqIOKeys if inCnt[k] > outCnt[k]]
   outGTInKeys = [k for k in notEqIOKeys if outCnt[k] > inCnt[k]]
   maxResLen = sum(len(vals) for key, vals in ag.items()) + 1

   if len(keys) == 0:
      return res
   elif len(keys) == 1:
      cur = keys[0]

   # 1. Choose starting vertex
   # If all vertices have same fanout as fanin - choose one with > 1 fanin or fanout
   elif eqIOCnts == nVertices:
      for i, key in enumerate(keys):
         if len(ag[key]) > 1:
            cur = key
            break
      if cur == s'':
         cur = keys[0]

   # If all but 2 vertices have same out-degree as in-degree
   elif eqIOCnts == nVertices - 2:
      if len(outGTInKeys)==len(inGTOutKeys):
         outGTkey = outGTInKeys[0]
         inGTkey = inGTOutKeys[0]
         # If 1 of the 2 vertices has fanout 1 > fanin and the other is opposite then
         #  set cur to vertex w/ fanout 1 > fanin 
         if inCnt[inGTkey]+1 == outCnt[inGTkey] and outCnt[outGTkey]+1 == inCnt[outGTkey]:
            cur = outGTkey

   # Else no euler cycle exists if cur isn't set
   if kind=='cycle' and cur == s'':
      return res

   # Path finding, set cur to key that has fanout > fanin
   if kind != 'cycle':
      cur = outGTInKeys[0] if len(outGTInKeys) > 0 else keys[0]

   # 2. Repeat until current vertex has no more out-going edges and stack is empty:
   while len(res) < maxResLen and cur != s'':
      nexts = Seqs() if kind != 'cycle' and cur not in paths else paths[cur]
      # nexts = Seqs() if not cycleOnly and cur not in paths else paths[cur]

      # If current vertex has no out-edges, add it to cycle and
      # remove the last vertex from the stack and set it as the current one
      if len(nexts) > 0:
         stack.append(cur)
         cur = nexts.pop(0)
      # Else, add the vertex to the stack, take any of its out-vertices and
      # remove that out-edge and set that out-vertex as the current vertex
      else:
         res.append(cur)
         cur = stack.pop() if len(stack) > 0 else s''

   if cur != s'':
      res.append(cur)
   while len(stack) > 0:
      res.append(stack.pop())
   res.reverse()
   return res

def reconstructGenome(seqs:Seqs, method='kmers', kind='cycle') -> seq: 
   """ Reconstruct genome from seqs with method and kind, where
   kind = 'cycle' | 'path' | 'universal'
   """
   ag = AdjGraph(seqs, method, 0).ag
   dna = eulerianPath(ag, kind) |> concatAdjSeqs
   if kind != 'universal':
      return dna 
   k = len(seqs[0]) - 1
   i = k // 2
   isOdd = k % 2 == 1 
   res = dna[i:-i]
   return res[1:] if isOdd else res

def pairedComposition(ptn:seq, k:int, d:int) -> Pairs:
   """ Returns pairs of ptn formed by its (k, d)-mer
   """
   s = list(ptn.split(k, 1))
   l = len(ptn) -k -d -2
   return [(x, y) for x,y in zip(s[:l], s[k+d:])]

