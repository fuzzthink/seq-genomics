from extensions import *
from helpers import product


def dpMinEqual(total:int, values:Ints) -> int:
   """ Dynamic Programming Coin Change
   Returns min number of value picked from values that equals total
   """
   maxVal = product(values)
   res = [0 for _ in range(total+1)]
   for j in range(1, total+1):
      res[j] = maxVal
      for i in range(0, len(values)):
         if j >= values[i]:
            if res[j - values[i]] + 1 < res[j]:
               res[j] = res[j - values[i]] + 1
   return res[total] if len(res) > total else 0

def manhattanTourist(Down:IntMat, Right:IntMat) -> int:
   """ 
   The Manhattan Tourist Problem
   Down:  n × (m + 1) matrix
   Right: (n + 1) × m matrix
   Returns length of a longest path from source (0, 0) to sink (n, m) in the rectangular grid
    whose edges are defined by the matrices Down and Right.
   """
   DnHt = len(Down)
   RtWd = len(Right[0])
   if DnHt+1 != len(Right):
      raise ValueError('manhattanTourist() -length (ht) of Down must be 1 < that of Right')
   if len(Down[0]) != RtWd+1:
      raise ValueError('manhattanTourist() -length of Down[0] (wd) must be 1 > that of Right')

   n = DnHt
   m = RtWd
   p = [[0 for i in range(m+1)] for j in range(n+1)]
   for i in range(1, n+1):
      p[i][0] = p[i-1][0] + Down[i-1][0]
   for i in range(1, m+1):
      p[0][i] = p[0][i-1] + Right[0][i-1]
   for i in range(1, n+1):
      for j in range(1, m+1):
         p[i][j] = max(p[i-1][j]+Down[i-1][j], p[i][j-1]+Right[i][j-1])      
   return p[n][m]
