from extensions import *
from helpers import product


def dpMinEqual(total:int, values:Ints) -> int:
   """ Dynamic Programming Coin Change
   Returns min number of value picked from values that equals total
   """
   maxVal = product(values)
   res = [0 for _ in range(total+1)]
   for j in range(1, total+1):
      res[j] = maxVal
      for i in range(0, len(values)):
         if j >= values[i]:
            if res[j - values[i]] + 1 < res[j]:
               res[j] = res[j - values[i]] + 1
   return res[total] if len(res) > total else 0

def manhattanTourist(Down:IntMat, Right:IntMat) -> int:
   """ 
   The Manhattan Tourist Problem
   Down:  downHt × (rightWd + 1) matrix
   Right: (downHt + 1) × rightWd matrix
   Returns length of a longest path from source (0, 0) to sink (n, m) in the rectangular grid
    whose edges are defined by the matrices Down and Right.
   """
   downHt = len(Down)
   rightWd = len(Right[0])
   if downHt+1 != len(Right):
      raise ValueError('manhattanTourist() -length (ht) of Down must be 1 < that of Right')
   if len(Down[0]) != rightWd+1:
      raise ValueError('manhattanTourist() -length of Down[0] (wd) must be 1 > that of Right')

   path = [[0 for i in range(rightWd+1)] for j in range(downHt+1)]
   for i in range(1, downHt+1):
      path[i][0] = path[i-1][0] + Down[i-1][0]
   for j in range(1, rightWd+1):
      path[0][j] = path[0][j-1] + Right[0][j-1]
   for i in range(1, downHt+1):
      for j in range(1, rightWd+1):
         path[i][j] = max(path[i-1][j]+Down[i-1][j], path[i][j-1]+Right[i][j-1])      
   return path[downHt][rightWd]

def LCSBackTrack(v:str, w:str) -> StrMat:
   """ Least Common Subsequence Backtrack
   Returns Mat of Backtracking pointers (symbols)
   """
   vLen = len(v)
   wLen = len(w)
   s = [[0 for i in range(wLen+1)] for j in range(vLen+1)] # length of an LCS
   res = [['' for i in range(wLen+1)] for j in range(vLen+1)]
   for i in range(1, vLen+1):
      for j in range(1, wLen+1):
         s[i][j] = max([
            s[i-1][j],
            s[i][j-1],
            s[i-1][j-1] + (1 if v[i-1]==w[j-1] else 0),
         ])
         if   s[i][j] == s[i-1][j]:
            res[i][j] = 'v'
         elif s[i][j] == s[i][j-1]:
            res[i][j] = '>'
         elif s[i][j] == s[i-1][j-1] + 1:
            res[i][j] = '\\'
   return res

def lcs(backtrack:StrMat, v:str, vLen:int, wLen:int) -> str:
   """ Least Common Subsequence
   """
   if vLen==0 or wLen==0:
      return ''
   if backtrack[vLen][wLen] == 'v':
      return lcs(backtrack, v, vLen-1, wLen)
   elif backtrack[vLen][wLen] == '>':
      return lcs(backtrack, v, vLen,   wLen-1)
   else:
      return lcs(backtrack, v, vLen-1, wLen-1) + v[vLen-1]

def leastCommonSubseq(seq1:str, seq2:str) -> str:
   backtrack = LCSBackTrack(seq1, seq2)
   return lcs(backtrack, seq1, len(seq1), len(seq2))

