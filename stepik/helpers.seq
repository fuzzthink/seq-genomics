from sys import argv
from extensions import *


def spaceSep[T](ls:list[T]) -> str:
   return ' '.join([str(k) for k in ls])

def nlSep[T](ls:list[T]) -> str:
   return '\n'.join([str(k) for k in ls])

def run(n:int) -> bool:
   x = argv[1] if len(argv) > 1 else ''
   res = x == '' or int(x) == n
   if res:
      print '\n'+str(n)+':'
   return res

def testIn[T](a:T, b:list[T]):
   if any(a==x for x in b):
      print "✓ result as expected"
   elif len(b)==1:
      print "  result:", a
      print "expected:", b[0]
   else:
      print "     result:", a
      print "exp one of:", b

def testVs[T](a:T, b:T):
   if a == b:
      print "✓ result as expected"
   else:
      print "  result:", a
      print "expected:", b


# Much simpler logic if can map(type, list)

def parseInts(s:str, sep=' ') -> Ints:
   return [int(x) for x in s.split(sep) if x.strip()]

def parseFloats(s:str, sep=' ') -> Floats:
   return [float(x) for x in s.split(sep) if x.strip()]

def parseSeqsStr(s:str, sep=' ') -> Seqs:
   return [seq(x) for x in s.split(sep) if x.strip()]

def parseSeqs(s:list[str], sep=' ') -> Seqs:
   return [seq(x) for x in s if x.strip()]

def parseProfile(d) -> Profile:
   return {seq(key): parseFloats(d[i]) for i, key in enumerate('ACGT')}

def parseGraphStr(st:str, sep='\n', arrow=' -> ') -> Adjacency:
   res = Adjacency()
   for s in [s.strip() for s in st.split(sep)]:
      x, y = s.split(arrow)
      res[seq(x)] = [seq(z) for z in y.split(',')] if ',' in y else [seq(y)]
   return res

def pairsStrToStrPairs(st:str, sep='\n', pairSep='|') -> StrPairs:
   res = StrPairs()
   for s in st.split(sep):
      a, b = s.split(pairSep)
      res.append((a, b))
   return res

def pairStrsToStrPairs(strs:Strs, sep='\n', pairSep='|') -> StrPairs:
   res = StrPairs()
   for s in strs:
      a, b = s.split(pairSep)
      res.append((a, b))
   return res

def toPairsStrs(pairs:Pairs, sep='|') -> Strs:
   """ Returns list of "(a1|b1)" representation of input pairs
   """
   return [f"({a}{sep}{b})" for a, b in pairs]

def toPairsStr(pairs:Pairs, sort=True) -> str:
   """ Returns sorted(default) "(a1|b1) (a2|b2) ..." representation of input pairs
   """
   strs = pairs |> toPairsStrs
   if sort:
      strs.sort()
   return strs |> spaceSep

def adjGraphStr(ag:Adjacency) -> str:
   res = [f"{x} -> {','.join([str(y) for y in ag[x]])}" for x in ag]
   return '\n'.join(res)

def arrowPathStr(seqs:Seqs) -> str:
   return '->'.join([str(s) for s in seqs])

def dPath(p:str):
   return 'stepik/data/'+p

def read(p:str) -> File:
   return open(dPath(p), 'r')

def readlines(p:str) -> list[str]:
   f = open(dPath(p), 'r')
   return f.readlines()

def readseqs(p:str) -> list[seq]:
   return list(seqs(dPath(p)))

def readGraphStr(p:str) -> Adjacency:
   s = '\n'.join(open(dPath(p), 'r').readlines())
   return parseGraphStr(s)

