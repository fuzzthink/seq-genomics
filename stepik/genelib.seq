from extensions import *
from seqlib import product

CodonLU = {
   "UUU":"F", "UUC":"F", "UUA":"L", "UUG":"L",
   "UCU":"S", "UCC":"S", "UCA":"S", "UCG":"S",
   "UAU":"Y", "UAC":"Y", "UAA":"*", "UAG":"*",
   "UGU":"C", "UGC":"C", "UGA":"*", "UGG":"W",
   "CUU":"L", "CUC":"L", "CUA":"L", "CUG":"L",
   "CCU":"P", "CCC":"P", "CCA":"P", "CCG":"P",
   "CAU":"H", "CAC":"H", "CAA":"Q", "CAG":"Q",
   "CGU":"R", "CGC":"R", "CGA":"R", "CGG":"R",
   "AUU":"I", "AUC":"I", "AUA":"I", "AUG":"M",
   "ACU":"T", "ACC":"T", "ACA":"T", "ACG":"T",
   "AAU":"N", "AAC":"N", "AAA":"K", "AAG":"K",
   "AGU":"S", "AGC":"S", "AGA":"R", "AGG":"R",
   "GUU":"V", "GUC":"V", "GUA":"V", "GUG":"V",
   "GCU":"A", "GCC":"A", "GCA":"A", "GCG":"A",
   "GAU":"D", "GAC":"D", "GAA":"E", "GAG":"E",
   "GGU":"G", "GGC":"G", "GGA":"G", "GGG":"G",
}
CodonRevLU = {
  # Ala
   'A': 'GCU GCC GCA GCG'.split(' '),
  # Cys
   'C': 'UGU UGC'.split(' '),
  # Asp
   'D': 'GAU GAC'.split(' '),
  # Glu
   'E': 'GAA GAG'.split(' '),
  # Phe
   'F': 'UUU UUC'.split(' '),
  # Gly
   'G': 'GGU GGC GGA GGG'.split(' '),
  # His
   'H': 'CAU CAC'.split(' '),
  # Ile
   'I': 'AUU AUC AUA'.split(' '),
  # Lys
   'K': 'AAA AAG'.split(' '),
  # Leu
   'L': 'CUU CUC CUA CUG UUA UUG'.split(' '),
  # Met
   'M': ['AUG'],
  # Asn
   'N': 'AAU AAC'.split(' '),
  # Pro
   'P': 'CCU CCC CCA CCG'.split(' '),
  # Gln
   'Q': 'CAA CAG'.split(' '),
  # Arg
   'R': 'CGU CGC CGA CGG AGA AGG'.split(' '),
  # Ser
   'S': 'UCU UCC UCA UCG AGU AGC'.split(' '),
  # Thr
   'T': 'ACU ACC ACA ACG'.split(' '),
  # Val
   'V': 'GUU GUC GUA GUG'.split(' '),
  # Trp
   'W': ['UGG'],
  # Tyr
   'Y': 'UAU UAC'.split(' '),
   '*': 'UAG UGA UAA'.split(' '),
}
AbrevLU = {
   'Tyr': 'Y',
   'Val': 'V',
   'Gly': 'G',
   'Ala': 'A',
   'Glu': 'E',
   'Asp': 'D',
   'Leu': 'L',
   'Arg': 'R',
   'Pro': 'P',
   'Gln': 'Q',
   'His': 'H',
   'Met': 'M',
   'Ile': 'I',
   'Arg': 'R',
   'Ser': 'S',
   'Thr': 'T',
   'Lys': 'K',
   'Asn': 'N',
   'Phe': 'F',
   'Trp': 'W',
   'Cys': 'C',
}
CodonKeyLen = 3


def abreviate(s:str, sep='-') -> str:
   return ''.join([AbrevLU[r] for r in s.split(sep)])

def strToRNA(dna:str) -> str:
   return dna.replace('T', 'U')
def seqToRNA(dna:seq) -> seq:
   return dna.replace('T', 'U')

def strToDNA(dna:str) -> str:
   return dna.replace('U', 'T')
def seqToDNA(dna:seq) -> seq:
   return dna.replace('U', 'T')

def translateProtein(ptn:str) -> str:
   """ Return mapping of ptn - str of CodonTable keys
   """
   if len(ptn) % 3 != 0:
      print "WARN: translateProtein() requires input of length % 3"
      return ''
   t = CodonLU
   return ''.join([t[str(c)] for c in seq(ptn).split(3, 3) if t[str(c)] != '*'])

def permCountsOf(ptn:str) -> int:
   """ Return count of possible keys mapping of ptn - str of CodonTable values
   """
   return product([len(CodonRevLU[c]) for c in ptn])

def encodePeptide(dna:str, ptn:str) -> Strs:
   """ Return Peptide encoding for ptn in dna
   """
   res = Strs()
   l = CodonKeyLen
   ptnLen = len(ptn)*l
   for Ptn in seq(dna).split(ptnLen, 1):
      pVs = ''
      rVs = ''
      P = seqToRNA(Ptn)
      R = seqToRNA(~Ptn)
      for p, r in [(P[i:i+l], R[i:i+l]) for i in range(0, ptnLen, l)]:
         if str(p) in CodonLU:
            pVs += CodonLU[str(p)]
         if str(r) in CodonLU:
            rVs += CodonLU[str(r)]
      if pVs==ptn or rVs==ptn:
         res.append(str(P))
   return [strToDNA(s) for s in res]

def calcPeptideLen(l:int) -> int:
   return l * (l - 1)

MassLU = {
   'G': 57,
   'A': 71,
   'S': 87,
   'P': 97,
   'V': 99,
   'T': 101,
   'C': 103,
   'I': 113,
   'L': 113,
   'N': 114,
   'D': 115,
   'K': 128,
   'Q': 128,
   'E': 129,
   'M': 131,
   'H': 137,
   'F': 147,
   'R': 156,
   'Y': 163,
   'W': 186,
}

def linearSpectrum(peptide:str) -> Ints:
   """ Cyclospectrum:  collection of all of the masses of its subpeptides,
    in addition to the mass 0 and the mass of the entire peptide, with
    masses ordered from smallest to largest. 
    """
   l = len(peptide)
   mass = [0]

   for s in peptide:
      mass.append(MassLU[s] + mass[-1])
   res = [0]+[mass[j] - mass[i] for i in range(l) for j in range(i+1, l+1)]
   return sorted(res)

